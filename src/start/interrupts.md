# 中斷

雖然中斷和異常在很多方面都不一樣，但是它們的操作和使用幾乎是一樣的，且它們也能被同一個中斷控制器處理。然而異常是由Cortex-M微架構定義的，中斷在命名和功能上總是由特定廠商(經常甚至是芯片)實現的。

中斷提供了更多的靈活性，當嘗試用一種高級的方法使用它們時，我們需要對這種靈活性進行解釋。但我們將不會在這本書裡涵蓋這些內容，最好把下面的東西記在心裡:
* 中斷有可以編程的優先級，其決定了它們的處理函數的執行順序。
* 中斷能嵌套且搶佔，i.e. 一箇中斷處理函數的執行可以被其它更高優先級的中斷打斷。
* 通常需要清除掉導致中斷被觸發的原因，避免無限地再次進入中斷處理函數。

運行時的初始化步驟總是相同的:
* 設置外設在想要的事件發生時產生中斷請求
* 在中斷控制器中設置需要的中斷處理函數的優先級
* 在中斷控制器中使能中斷處理函數

與異常相似，`cortex-m-rt` crate提供了一個[`interrupt`]屬性去聲明中斷處理函數。可用的中斷(及它們在中斷向量表中的位置)通常由`svd2rust`從一個SVD描述文件自動地生成。

[`interrupt`]: https://docs.rs/cortex-m-rt-macros/0.1.5/cortex_m_rt_macros/attr.interrupt.html

``` rust,ignore
// Timer2中斷的中斷處理函數
#[interrupt]
fn TIM2() {
    // ..
    // 清除生成中斷請求的原因
}
```

中斷處理函數和異常處理函數一樣看起來像是普通的函數(除了沒有入參)。然而由於特殊的調用規定，它不能被固件的其它部分直接調用。然而，可以在軟件中生成中斷請求，轉移到中斷處理函數中。

與異常處理函數一樣，也能在中斷處理函數中聲明`static mut`變量且保持 *safe* 狀態。

``` rust,ignore
#[interrupt]
fn TIM2() {
    static mut COUNT: u32 = 0;

    // `COUNT` 的類型是 `&mut u32` 且它用起來安全
    *COUNT += 1;
}
```

關於這裡所說的機制的更多細節描述，請參考[異常章節]。

[異常章節]: ./exceptions.md
