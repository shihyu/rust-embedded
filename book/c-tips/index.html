<!DOCTYPE HTML>
<html lang="zh-CN" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>給嵌入式C開發者的貼士 - The Embedded Rust Book</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../intro/index.html"><strong aria-hidden="true">1.</strong> 引言</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../intro/hardware.html"><strong aria-hidden="true">1.1.</strong> 硬件</a></li><li class="chapter-item expanded "><a href="../intro/no-std.html"><strong aria-hidden="true">1.2.</strong> no_std</a></li><li class="chapter-item expanded "><a href="../intro/tooling.html"><strong aria-hidden="true">1.3.</strong> 工具</a></li><li class="chapter-item expanded "><a href="../intro/install.html"><strong aria-hidden="true">1.4.</strong> 安裝</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../intro/install/linux.html"><strong aria-hidden="true">1.4.1.</strong> Linux</a></li><li class="chapter-item expanded "><a href="../intro/install/macos.html"><strong aria-hidden="true">1.4.2.</strong> MacOS</a></li><li class="chapter-item expanded "><a href="../intro/install/windows.html"><strong aria-hidden="true">1.4.3.</strong> Windows</a></li><li class="chapter-item expanded "><a href="../intro/install/verify.html"><strong aria-hidden="true">1.4.4.</strong> 驗證工具鏈的安裝</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../start/index.html"><strong aria-hidden="true">2.</strong> 開始</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../start/qemu.html"><strong aria-hidden="true">2.1.</strong> QEMU</a></li><li class="chapter-item expanded "><a href="../start/hardware.html"><strong aria-hidden="true">2.2.</strong> 硬件</a></li><li class="chapter-item expanded "><a href="../start/registers.html"><strong aria-hidden="true">2.3.</strong> 存儲映射的寄存器</a></li><li class="chapter-item expanded "><a href="../start/semihosting.html"><strong aria-hidden="true">2.4.</strong> 半主機模式</a></li><li class="chapter-item expanded "><a href="../start/panicking.html"><strong aria-hidden="true">2.5.</strong> 運行時恐慌(Panicking)</a></li><li class="chapter-item expanded "><a href="../start/exceptions.html"><strong aria-hidden="true">2.6.</strong> 異常</a></li><li class="chapter-item expanded "><a href="../start/interrupts.html"><strong aria-hidden="true">2.7.</strong> 中斷</a></li><li class="chapter-item expanded "><a href="../start/io.html"><strong aria-hidden="true">2.8.</strong> IO</a></li></ol></li><li class="chapter-item expanded "><a href="../peripherals/index.html"><strong aria-hidden="true">3.</strong> 外設</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../peripherals/a-first-attempt.html"><strong aria-hidden="true">3.1.</strong> Rust嚐鮮</a></li><li class="chapter-item expanded "><a href="../peripherals/borrowck.html"><strong aria-hidden="true">3.2.</strong> 借用檢查器</a></li><li class="chapter-item expanded "><a href="../peripherals/singletons.html"><strong aria-hidden="true">3.3.</strong> 單例</a></li></ol></li><li class="chapter-item expanded "><a href="../static-guarantees/index.html"><strong aria-hidden="true">4.</strong> 靜態保障(static guarantees)</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../static-guarantees/typestate-programming.html"><strong aria-hidden="true">4.1.</strong> 類型狀態編程</a></li><li class="chapter-item expanded "><a href="../static-guarantees/state-machines.html"><strong aria-hidden="true">4.2.</strong> 把外設當作狀態機</a></li><li class="chapter-item expanded "><a href="../static-guarantees/design-contracts.html"><strong aria-hidden="true">4.3.</strong> 設計約定</a></li><li class="chapter-item expanded "><a href="../static-guarantees/zero-cost-abstractions.html"><strong aria-hidden="true">4.4.</strong> 零成本抽象</a></li></ol></li><li class="chapter-item expanded "><a href="../portability/index.html"><strong aria-hidden="true">5.</strong> 可移植性</a></li><li class="chapter-item expanded "><a href="../concurrency/index.html"><strong aria-hidden="true">6.</strong> 併發</a></li><li class="chapter-item expanded "><a href="../collections/index.html"><strong aria-hidden="true">7.</strong> 容器</a></li><li class="chapter-item expanded "><a href="../design-patterns/index.html"><strong aria-hidden="true">8.</strong> 設計模式</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../design-patterns/hal/index.html"><strong aria-hidden="true">8.1.</strong> HALs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../design-patterns/hal/checklist.html"><strong aria-hidden="true">8.1.1.</strong> 列表</a></li><li class="chapter-item expanded "><a href="../design-patterns/hal/naming.html"><strong aria-hidden="true">8.1.2.</strong> 命名</a></li><li class="chapter-item expanded "><a href="../design-patterns/hal/interoperability.html"><strong aria-hidden="true">8.1.3.</strong> 互操性</a></li><li class="chapter-item expanded "><a href="../design-patterns/hal/predictability.html"><strong aria-hidden="true">8.1.4.</strong> 可預見性</a></li><li class="chapter-item expanded "><a href="../design-patterns/hal/gpio.html"><strong aria-hidden="true">8.1.5.</strong> GPIO</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../c-tips/index.html" class="active"><strong aria-hidden="true">9.</strong> 給嵌入式C開發者的貼士</a></li><li class="chapter-item expanded "><a href="../interoperability/index.html"><strong aria-hidden="true">10.</strong> 互操性</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../interoperability/c-with-rust.html"><strong aria-hidden="true">10.1.</strong> 使用C的Rust</a></li><li class="chapter-item expanded "><a href="../interoperability/rust-with-c.html"><strong aria-hidden="true">10.2.</strong> 使用Rust的C</a></li></ol></li><li class="chapter-item expanded "><a href="../unsorted/index.html"><strong aria-hidden="true">11.</strong> 沒有排序的主題</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../unsorted/speed-vs-size.html"><strong aria-hidden="true">11.1.</strong> 優化: 速度與大小間的博弈</a></li><li class="chapter-item expanded "><a href="../unsorted/math.html"><strong aria-hidden="true">11.2.</strong> 執行數學運算</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><a href="../appendix/glossary.html">附錄A: 詞彙表</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Embedded Rust Book</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/xxchang/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="給嵌入式c開發者的貼士"><a class="header" href="#給嵌入式c開發者的貼士">給嵌入式C開發者的貼士</a></h1>
<p>這個章節收集了可能對於剛開始編寫Rust的，有經驗的嵌入式C開發者來說，有用的各種各樣的貼士。它將解釋你在C中可能已經用到的那些東西與Rust中的有何不同。</p>
<h2 id="預處理器"><a class="header" href="#預處理器">預處理器</a></h2>
<p>在嵌入式C中，為了各種各樣的目的使用預處理器是很常見的，比如:</p>
<ul>
<li>使用<code>#ifdef</code>編譯時選擇代碼塊</li>
<li>編譯時的數組大小和計算</li>
<li>用來簡化常見的模式的宏(避免調用函數的開銷)</li>
</ul>
<p>在Rust中沒有預處理器，所以許多案例有不同的處理方法。本章節剩下的部分，我們將介紹各種替代預處理器的方法。</p>
<h3 id="編譯時的代碼選擇"><a class="header" href="#編譯時的代碼選擇">編譯時的代碼選擇</a></h3>
<p>Rust中最接近<code>#ifdef ... #endif</code>的是<a href="https://doc.rust-lang.org/cargo/reference/manifest.html#the-features-section">Cargo features</a>。這些比C預處理器更正式一點: 每個crate顯式列舉的，所有可能的features只能是關了的或者打開了的。當你把一個crate列為依賴項時，Features被打開，且是可添加的：如果你依賴樹中的任何crate為另一個crate打開了一個feature，那麼這個feature將為所有使用那個crate的用戶而打開。</p>
<p>比如，你可能有一個crate，其提供一個信號處理的基本類型庫(library of signal processing primitives)。每個基本類型可能帶來一些額外的時間去編譯大量的常量，你想要避開這些常量。你可以為你的<code>Cargo.toml</code>中每個組件聲明一個Cargo feature。</p>
<pre><code class="language-toml">[features]
FIR = []
IIR = []
</code></pre>
<p>然後，在你的代碼中，使用<code>#[cfg(feature="FIR")]</code>去控制要包含什麼東西。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// 在你的頂層的lib.rs中
#[cfg(feature="FIR")]
pub mod fir;

#[cfg(feature="IIR")]
pub mod iir;
<span class="boring">}</span></code></pre></pre>
<p>同樣地，你可以控制，只有當某個feature <em>沒有</em> 被打開時，包含代碼塊，或者某些features的組合被打開或者被關閉時。</p>
<p>另外，Rust提供了許多可以使用的自動配置了的條件，比如<code>target_arch</code>用來選擇不同的代碼所基於的架構。對於條件編譯的全部細節，可以參看the Rust reference的<a href="https://doc.rust-lang.org/reference/conditional-compilation.html">conditional compilation</a>章節。</p>
<p>條件編譯將只應用於下一條語句或者塊。如果一個塊不能在現在的作用域中被使用，那麼<code>cfg</code>屬性將需要被多次使用。值得注意的是大多數時間，僅是包含所有的代碼而讓編譯器在優化時去刪除死代碼(dead code)更好，通常，在移除不使用的代碼方面的工作，編譯器做得很好。</p>
<h3 id="編譯時大小和計算"><a class="header" href="#編譯時大小和計算">編譯時大小和計算</a></h3>
<p>Rust支持<code>const fn</code>，<code>const fn</code>是在編譯時可以被計算的函數，因此可以被用在需要常量的地方，比如在數組的大小中。這個能與上述的features一起使用，比如:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const fn array_size() -&gt; usize {
    #[cfg(feature="use_more_ram")]
    { 1024 }
    #[cfg(not(feature="use_more_ram"))]
    { 128 }
}

static BUF: [u32; array_size()] = [0u32; array_size()];
<span class="boring">}</span></code></pre></pre>
<p>這些對於stable版本的Rust來說是新的特性，從1.31開始引入，因此文檔依然很少。在寫這篇文章的時候<code>const fn</code>可用的功能也非常有限; 在未來的Rust release版本中，我們可以期望<code>const fn</code>將帶來更多的功能。</p>
<h3 id="宏"><a class="header" href="#宏">宏</a></h3>
<p>Rust提供一個極度強大的<a href="https://doc.rust-lang.org/book/ch19-06-macros.html">宏系統</a>。雖然C預處理器幾乎直接在你的源代碼之上進行操作，但是Rust宏系統可以在一個更高的級別上操作。存在兩種Rust宏: <em>聲明宏</em> 和 <em>過程宏</em> 。前者更簡單也最常見; 它們看起來像是函數調用，且能擴展成一個完整的表達式，語句，項，或者模式。過程宏更復雜但是卻能讓Rust更強大: 它們可以把任一條Rust語法變成一個新的Rust語法。</p>
<p>通常，你可能想知道在那些使用一個C預處理器宏的地方，能否使用一個聲明宏做同樣的工作。你可以在crate中定義它們，且在你的crate中輕鬆使用它們或者導出給其他人用。但是請注意，因為它們必須擴展成完整的表達式，語句，項或者模式，因此C預處理器宏的某些用例沒法用，比如可以擴展成一個變量名的一部分的宏或者可以把列表中的項擴展成不完整的集合的宏。</p>
<p>和Cargo features一樣，值得考慮下你是否真的需要宏。在一些例子中一個常規的函數更容易被理解，它也能被內聯成和一個和宏一樣的代碼。<code>#[inline]</code>和<code>#[inline(always)]</code> <a href="https://doc.rust-lang.org/reference/attributes.html#inline-attribute">attributes</a> 能讓你更深入控制這個過程，這裡也要小心 - 編譯器會從同一個crate的恰當的地方自動地內聯函數，因此不恰當地強迫它內聯函數實際可能會導致性能下降。</p>
<p>研究完整的Rust宏系統超出了本節內容，因此我們鼓勵你去查閱Rust文檔瞭解完整的細節。</p>
<h2 id="編譯系統"><a class="header" href="#編譯系統">編譯系統</a></h2>
<p>大多數Rust crates使用Cargo編譯 (即使這不是必須的)。這解決了傳統編譯系統帶來的許多難題。然而，你可能希望自定義編譯過程。為了實現這個目的，Cargo提供了<a href="https://doc.rust-lang.org/cargo/reference/build-scripts.html"><code>build.rs</code>腳本</a>。它們是可以根據需要與Cargo編譯系統進行交互的Rust腳本。</p>
<p>與編譯腳本有關的常見用例包括:</p>
<ul>
<li>提供編譯時信息，比如靜態嵌入編譯日期或者Git commit hash進你的可執行文件中</li>
<li>根據被選擇的features或者其它邏輯在編譯時生成鏈接腳本</li>
<li>改變Cargo的編譯配置</li>
<li>添加額外的靜態鏈接庫以進行鏈接</li>
</ul>
<p>現在還不支持post-build腳本，通常將它用於像是從編譯的對象自動生生成二進制文件或者打印編譯信息這類任務中。</p>
<h3 id="交叉編譯"><a class="header" href="#交叉編譯">交叉編譯</a></h3>
<p>為你的編譯系統使用Cargo也能簡化交叉編譯。在大多數例子裡，告訴Cargo <code>--target thumbv6m-none-eabi</code>就行了，可以在<code>target/thumbv6m-none-eabi/debug/myapp</code>中找到一個合適的可執行文件。</p>
<p>對於那些並不是Rust原生支持的平臺，將需要自己為那個目標平臺編譯<code>libcore</code>。遇到這樣的平臺，<a href="https://github.com/japaric/xargo">Xargo</a>可以作為Cargo的替代來使用，它可以自動地為你編譯<code>libcore</code>。</p>
<h2 id="迭代器與數組訪問"><a class="header" href="#迭代器與數組訪問">迭代器與數組訪問</a></h2>
<p>在C中，你可能習慣於通過索引直接訪問數組:</p>
<pre><code class="language-c">int16_t arr[16];
int i;
for(i=0; i&lt;sizeof(arr)/sizeof(arr[0]); i++) {
    process(arr[i]);
}
</code></pre>
<p>在Rust中，這是一個反模式(anti-pattern)：索引訪問可能會更慢(因為它可能需要做邊界檢查)且可能會阻止編譯器的各種優化。這是一個重要的區別，值得再重複一遍: Rust會在手動的數組索引上進行越界檢查以保障內存安全性，而C允許索引數組外的內容。</p>
<p>可以使用迭代器來替代:</p>
<pre><code class="language-rust ignore">let arr = [0u16; 16];
for element in arr.iter() {
    process(*element);
}</code></pre>
<p>迭代器提供了一個有強大功能的數組，在C中你不得不手動實現它，比如chaining，zipping，enumerating，找到最小或最大值，summing，等等。迭代器方法也能被鏈式調用，提供了可讀性非常高的數據處理代碼。</p>
<p>閱讀<a href="https://doc.rust-lang.org/book/ch13-02-iterators.html">Iterators in the Book</a>和<a href="https://doc.rust-lang.org/core/iter/trait.Iterator.html">Iterator documentation</a>獲取更多細節。</p>
<h2 id="引用和指針"><a class="header" href="#引用和指針">引用和指針</a></h2>
<p>在Rust中，存在指針(被叫做 <a href="https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html#dereferencing-a-raw-pointer"><em>裸指針</em></a>)但是隻能在特殊的環境中被使用，因為解引用裸指針總是被認為是<code>unsafe</code>的 -- Rust通常不能保障指針背後有什麼。</p>
<p>在大多數例子裡，我們使用 <em>引用</em> 來替代，由<code>&amp;</code>符號指出，或者 <em>可變引用</em>，由<code>&amp;mut</code>指出。引用與指針相似，因為它能被解引用來訪問底層的數據，但是它們是Rust的所有權系統的一個關鍵部分: Rust將嚴格強迫你在任何給定時間只有一個可變引用 <em>或者</em> 對相同數據的多個不變引用。</p>
<p>在實踐中，這意味著你必須要更加小心你是否需要對數據的可變訪問：在C中默認是可變的，你必須顯式地使用<code>const</code>，在Rust中正好相反。</p>
<p>某個情況下，你可能仍然要使用裸指針直接與硬件進行交互(比如，寫入一個指向DMA外設寄存器中的緩存的指針)，它們也被所有的外設訪問crates在底層使用，讓你可以讀取和寫入存儲映射寄存器。</p>
<h2 id="volatile訪問"><a class="header" href="#volatile訪問">Volatile訪問</a></h2>
<p>在C中，某個變量可能被標記成<code>volatile</code>，向編譯器指出，變量中的值在訪問間可能改變。Volatile變量通常用於一個與存儲映射的寄存器有關的嵌入式上下文中。</p>
<p>在Rsut中，並不使用<code>volatile</code>標記變量，我們使用特定的方法去執行volatile訪問: <a href="https://doc.rust-lang.org/core/ptr/fn.read_volatile.html"><code>core::ptr::read_volatile</code></a> 和 <a href="https://doc.rust-lang.org/core/ptr/fn.write_volatile.html"><code>core::ptr::write_volatile</code></a>。這些方法使用一個 <code>*const T</code> 或者一個 <code>*mut T</code> (上面說的 <em>裸指針</em> )，執行一個volatile讀取或者寫入。</p>
<p>比如，在C中你可能這樣寫:</p>
<pre><code class="language-c">volatile bool signalled = false;

void ISR() {
    // 提醒中斷已經發生了
    signalled = true;
}

void driver() {
    while(true) {
        // 睡眠直到信號來了
        while(!signalled) { WFI(); }
        // 重置信號提示符
        signalled = false;
        // 執行一些正在等待這個中斷的任務
        run_task();
    }
}
</code></pre>
<p>在Rust中對每個訪問使用volatile方法能達到相同的效果:</p>
<pre><code class="language-rust ignore">static mut SIGNALLED: bool = false;

#[interrupt]
fn ISR() {
    // 提醒中斷已經發生
    // (在正在的代碼中，你應該考慮一個更高級的基本類型,
    // 比如一個原子類型)
    unsafe { core::ptr::write_volatile(&amp;mut SIGNALLED, true) };
}

fn driver() {
    loop {
        // 睡眠直到信號來了
        while unsafe { !core::ptr::read_volatile(&amp;SIGNALLED) } {}
        // 重置信號指示符
        unsafe { core::ptr::write_volatile(&amp;mut SIGNALLED, false) };
        // 執行一些正在等待中斷的任務
        run_task();
    }
}</code></pre>
<p>在示例代碼中有些事情值得注意:</p>
<ul>
<li>我們可以把<code>&amp;mut SIGNALLED</code>傳遞給要求<code>*mut T</code>的函數中，因為<code>&amp;mut T</code>會自動轉換成一個<code>*mut T</code> (對於<code>*const T</code>來說是一樣的)</li>
<li>我們需要為<code>read_volatile</code>/<code>write_volatile</code>方法使用<code>unsafe</code>塊，因為它們是<code>unsafe</code>的函數。確保操作安全變成了程序員的責任：看方法的文檔獲得更多細節。</li>
</ul>
<p>在你的代碼中直接使用這些函數是很少見的，因為它們通常由更高級的庫封裝起來為你提供服務。對於存儲映射的外設，提供外設訪問的crates將自動實現volatile訪問，而對於併發的基本類型，存在更好的抽象可用。(看<a href="../concurrency/index.html">併發章節</a>)</p>
<h2 id="填充和對齊類型"><a class="header" href="#填充和對齊類型">填充和對齊類型</a></h2>
<p>在嵌入式C中，告訴編譯器一個變量必須遵守某個對齊或者一個結構體必須被填充而不是對齊，是很常見的行為，通常是為了滿足特定的硬件或者協議要求。</p>
<p>在Rust中，這由一個結構體或者聯合體上的<code>repr</code>屬性來控制。默認的表示(representation)不保障佈局，因此不應該被用於與硬件或者C互用的代碼。編譯器可能會對結構體成員重新排序或者插入填充，且這種行為可能在未來的Rust版本中改變。</p>
<pre><pre class="playground"><code class="language-rust">struct Foo {
    x: u16,
    y: u8,
    z: u16,
}

fn main() {
    let v = Foo { x: 0, y: 0, z: 0 };
    println!("{:p} {:p} {:p}", &amp;v.x, &amp;v.y, &amp;v.z);
}

// 0x7ffecb3511d0 0x7ffecb3511d4 0x7ffecb3511d2
// 注意為了改進填充，順序已經被變成了x, z, y</code></pre></pre>
<p>使用<code>repr(C)</code>可以確保佈局可以與C互用。</p>
<pre><pre class="playground"><code class="language-rust">#[repr(C)]
struct Foo {
    x: u16,
    y: u8,
    z: u16,
}

fn main() {
    let v = Foo { x: 0, y: 0, z: 0 };
    println!("{:p} {:p} {:p}", &amp;v.x, &amp;v.y, &amp;v.z);
}

// 0x7fffd0d84c60 0x7fffd0d84c62 0x7fffd0d84c64
// 順序被保留了，佈局將不會隨著時間而改變
// `z`是兩個字節對齊，因此在`y`和`z`之間填充了一個字節。</code></pre></pre>
<p>使用<code>repr(packed)</code>去確保表示(representation)被填充了:</p>
<pre><pre class="playground"><code class="language-rust">#[repr(packed)]
struct Foo {
    x: u16,
    y: u8,
    z: u16,
}

fn main() {
    let v = Foo { x: 0, y: 0, z: 0 };
    // 引用必須總是對齊的，因此為了檢查結構體字段的地址，我們使用
    // `std::ptr::addr_of!()`去獲取一個裸指針而不僅是打印`&amp;v.x`
    let px = std::ptr::addr_of!(v.x);
    let py = std::ptr::addr_of!(v.y);
    let pz = std::ptr::addr_of!(v.z);
    println!("{:p} {:p} {:p}", px, py, pz);
}

// 0x7ffd33598490 0x7ffd33598492 0x7ffd33598493
// 在`y`和`z`沒有填充被插入，因此現在`z`沒有被對齊。</code></pre></pre>
<p>注意使用<code>repr(packed)</code>也會將類型的對齊設置成<code>1</code> 。</p>
<p>最後，為了指定一個特定的對齊，可以使用<code>repr(align(n))</code>，<code>n</code>是要對齊的字節數(必須是2的冪):</p>
<pre><pre class="playground"><code class="language-rust">#[repr(C)]
#[repr(align(4096))]
struct Foo {
    x: u16,
    y: u8,
    z: u16,
}

fn main() {
    let v = Foo { x: 0, y: 0, z: 0 };
    let u = Foo { x: 0, y: 0, z: 0 };
    println!("{:p} {:p} {:p}", &amp;v.x, &amp;v.y, &amp;v.z);
    println!("{:p} {:p} {:p}", &amp;u.x, &amp;u.y, &amp;u.z);
}

// 0x7ffec909a000 0x7ffec909a002 0x7ffec909a004
// 0x7ffec909b000 0x7ffec909b002 0x7ffec909b004
// `u`和`v`兩個實例已經被放置在4096字節的對齊上。
// 它們地址結尾處的`000`證明了這件事。</code></pre></pre>
<p>注意我們可以結合<code>repr(C)</code>和<code>repr(align(n))</code>來獲取一個對齊的c兼容的佈局。不允許將<code>repr(align(n))</code>和<code>repr(packed)</code>一起使用，因為<code>repr(packed)</code>將對齊設置為<code>1</code>。也不允許一個<code>repr(packed)</code>類型包含一個<code>repr(align(n))</code>類型。</p>
<p>關於類型佈局更多的細節，參考the Rust Reference的<a href="https://doc.rust-lang.org/reference/type-layout.html">type layout</a>章節。</p>
<h2 id="其它資源"><a class="header" href="#其它資源">其它資源</a></h2>
<ul>
<li>這本書中:
<ul>
<li><a href="../interoperability/c-with-rust.html">使用C的Rust</a></li>
<li><a href="../interoperability/rust-with-c.html">使用Rust的C</a></li>
</ul>
</li>
<li><a href="https://docs.rust-embedded.org/faq.html">The Rust Embedded FAQs</a></li>
<li><a href="http://blahg.josefsipek.net/?p=580">Rust Pointers for C Programmers</a></li>
<li><a href="https://github.com/diwic/reffers-rs/blob/master/docs/Pointers.md">I used to use pointers - now what?</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../design-patterns/hal/gpio.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../interoperability/index.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../design-patterns/hal/gpio.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../interoperability/index.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
